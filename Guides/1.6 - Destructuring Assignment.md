# Destructuring Assignment

De to mest anvendte datastrukturer i JavaScript er Object og Array.

Objekter tillader os at oprette en enkelt variabel, som kan gemme dataelementer efter en bestemt egenskab, og arrays giver os mulighed for at samle dataelementer i en sorteret samling.

Men når vi skal videregive disse strukturer til en funktion, behøver det muligvis ikke være et objekt / array som helhed, men snarere små individuelle stykker af objektet eller arrayet.

*Destructuring Assignment* er en særlig syntaks, der giver os mulighed for at "pakke" arrays eller objekter ud i en masse variabler, som i mange situationer kan være mere praktisk at arbejde med. Destrukturering fungerer også godt med komplekse funktioner, der har mange parametre, standardværdier osv.

## Array destrukturering
Herunder kan du se et eksempel på, hvordan et arrayet destruktureres i variabler:
```js
// Vi har et array med fornavn og efternavn
let arr = ["Jens", "Jensen"]

// destructuring assignment
// sætter firstName = arr[0]
// og lastname = arr[1]
let [firstName, lastName] = arr;

alert(firstName); // Jens
alert(lastName);  // Jensen
```
Nu kan vi arbejde med variabler i stedet for array elementer.

Vi kan få samme resultat, når vi kombinerer det med en *split()* metode eller andre array-returneringsmetoder:
```js
let [firstName, lastName] = "Jens Jensen".split(' ');
```
### Destruktion” betyder ikke ”destruktiv.
Det kaldes *destructuring*, fordi det "destrukturerer" ved at kopiere elementer til variabler. Men selve arrayet er ikke ændret.

Det er egentlig bare en kortere måde at skrive følgende kode på:
```js
// let [firstName, lastName] = arr;
let firstName = arr[0];
let lastName = arr[1];
```
### Udeluk elementer ved hjælp af komma
Uønskede elementer i arrayet kan også udelukkes via et ekstra komma:
```js
// Det andet element er ikke nødvendigt
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); //=> Consul
```

I koden ovenfor springes det andet element i arrayet over, det tredje tildeles titlen, og resten af array elementerne springes også over (da der ikke er nogen variabler til dem).

### Fungerer med enhver iterabel datatype på højre side
... Faktisk kan vi bruge den med alle iterable datatyper, og ikke kun arrays:
```js 
let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
```
### Tildel til noget på venstre side
Vi kan bruge alle "tildelte ting" i venstre side.

For eksempel en objekt egenskab:
```js
let user = {};
[user.name, user.lastname] = "Jens Jensen".split(' ');

alert(user.name); // Jens
```
### Looping med .entries()
I det forrige kapitel så vi metoden Object.entries (obj).

Vi kan bruge det til at destrukturere et loop over nøgler og værdier for et objekt:
```js
let user = {
  name: "John",
  age: 30
};

// loop over keys-and-values
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, og age:30
}
```
...og det samme med en *Map()*:
```js
let user = new Map();
user.set("name", "John");
user.set("age", "30");

for(let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, og age:30
}
```










Destruktionstildeling, der findes på mange andre sprog, kan være en meget praktisk funktion, når du beskæftiger dig med objekter eller arrays.

Lad os sige, at vi vil gøre dette:

var navn = bruger.navn;
var e-mail = bruger.email;
Med ES6 kan vi bruge det, der kaldes en destruktureringsopgave:

var {name, email} = bruger;
Alternativt, hvis vi vil bruge variabelnavne, der adskiller sig fra ejendomsnavne ...

// dette erklærer to variabler, userName og userEmail
var {name: userName, email: userEmail} = user;
Hvilket funktionelt svarer til:

var brugernavn = brugernavn;
var userEmail = user.email;
Hvor er dette nyttigt?

Et almindeligt mønster er at bruge objekter til at passere et stort antal parametre, især hvis parametrene er valgfri. Dette scenario er, hvor destruktureringen skinner:

funktionskompleks ({navn, e-mail, telefon = null}) {
  // variabler "navn", "e-mail" og "telefon" er tilgængelige her
}
 
var bruger = {
  navn: 'foo',
  e-mail: 'bar',
  telefon: '123456'
};
kompleks (bruger);
Bemærk, at vi brugte destruktion i funktionsparameterlisten - det fungerer også der og understøtter endda standardindstillinger!

Ved at gøre dette får vi en række fordele:

Vi gør de egenskaber, som objektparameteren kræver eksplicit. Et almindeligt problem er at se, at en funktion tager et objekt, men ikke at vide, hvilken type objekt. Nu er det løst.
Vi kan have standardindstillinger. Ingen grund til at kontrollere, om ejendommen er der
Vi gør valgfri egenskaber eksplicit. Ved at angive en standard for en ejendom ser enhver, der læser koden, at ejendommen er valgfri.
Eksplicit synlige ting gør koden lettere at vedligeholde, da du ikke behøver at gætte eller læse hele funktionen for at finde ud af det.

Du kan gøre mange smarte ting med destruktion. For omfattende eksempler bør du tjekke Scott Allens indlæg om ES6-destruktion.

Pas på ikke at tage tingene for langt. Det er muligt at gøre din kode sværere at læse med for meget brug af destruktion:

lad {adresse: {home: {street}} = bruger;
 
// svarer til:
lad gade = bruger.adresse.hjem.gade;
Du kan sandsynligvis se eksemplet uden at ødelægge ovenstående er meget lettere at forstå.

